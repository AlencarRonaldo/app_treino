const { chromium } = require('playwright');
const fs = require('fs');

async function analyzetreinosappStatus() {
    console.log('üîç INICIANDO VERIFICA√á√ÉO COMPLETA DO TREINOSAPP');
    console.log('=' .repeat(60));
    
    const browser = await chromium.launch({
        headless: false,
        viewport: { width: 375, height: 812 }
    });
    
    const context = await browser.newContext({
        userAgent: 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)'
    });
    
    const page = await context.newPage();
    
    // Arrays para capturar logs e erros
    const consoleLogs = [];
    const errors = [];
    const networkRequests = [];
    
    // Handlers para capturar informa√ß√µes
    page.on('console', msg => {
        const logEntry = {
            type: msg.type(),
            text: msg.text(),
            location: msg.location(),
            timestamp: new Date().toISOString()
        };
        consoleLogs.push(logEntry);
        console.log(`üìä Console [${msg.type()}]: ${msg.text()}`);
    });
    
    page.on('pageerror', error => {
        const errorEntry = {
            message: error.message,
            stack: error.stack,
            timestamp: new Date().toISOString()
        };
        errors.push(errorEntry);
        console.log(`‚ùå Page Error: ${error.message}`);
    });
    
    page.on('request', request => {
        networkRequests.push({
            url: request.url(),
            method: request.method(),
            timestamp: new Date().toISOString()
        });
    });
    
    try {
        console.log('üì° Conectando ao TreinosApp em localhost:8081...');
        const startTime = Date.now();
        
        // Navegar para o app
        await page.goto('http://localhost:8081', { 
            waitUntil: 'networkidle',
            timeout: 30000 
        });
        
        const loadTime = Date.now() - startTime;
        console.log(`‚úÖ Conex√£o estabelecida em ${loadTime}ms`);
        
        // Aguardar um pouco para o app carregar completamente
        await page.waitForTimeout(5000);
        
        console.log('\nüîç AN√ÅLISE 1: VERIFICANDO ERRO registerWebModule');
        const registerError = consoleLogs.find(log => 
            log.text.includes('registerWebModule') && log.type === 'error'
        );
        
        if (registerError) {
            console.log(`‚ùå Erro registerWebModule AINDA PRESENTE: ${registerError.text}`);
        } else {
            console.log('‚úÖ Erro registerWebModule foi CORRIGIDO!');
        }
        
        console.log('\nüîç AN√ÅLISE 2: VERIFICANDO RENDERIZA√á√ÉO');
        const bodyContent = await page.locator('body').innerHTML();
        const hasSignificantContent = bodyContent.trim().length > 200;
        
        if (hasSignificantContent) {
            console.log('‚úÖ Conte√∫do significativo sendo renderizado (n√£o mais tela branca)');
            
            // Procurar por elementos espec√≠ficos
            const elements = {
                root: await page.locator('#root').count(),
                reactRoot: await page.locator('[data-reactroot]').count(),
                buttons: await page.locator('button').count(),
                inputs: await page.locator('input').count(),
                loginElements: await page.locator('[class*="login"], [id*="login"], [data-testid*="login"]').count(),
                errorBoundary: await page.locator('[class*="error"], [data-testid*="error"]').count()
            };
            
            console.log('üìä Elementos encontrados:', elements);
            
            // Verificar se temos indica√ß√µes de sucesso
            const pageContent = await page.content();
            const successIndicators = ['TreinosApp', 'Login', 'Entrar'].filter(indicator =>
                pageContent.toLowerCase().includes(indicator.toLowerCase())
            );
            
            if (successIndicators.length > 0) {
                console.log(`‚úÖ Indicadores de sucesso: ${successIndicators.join(', ')}`);
            }
            
        } else {
            console.log('‚ùå Ainda h√° tela branca ou conte√∫do insuficiente');
        }
        
        console.log('\nüîç AN√ÅLISE 3: LOGS DO CONSOLE');
        const errorLogs = consoleLogs.filter(log => log.type === 'error');
        const warningLogs = consoleLogs.filter(log => log.type === 'warning');
        const infoLogs = consoleLogs.filter(log => log.type === 'log' || log.type === 'info');
        
        console.log(`üìä Total de logs: ${consoleLogs.length}`);
        console.log(`‚ùå Erros: ${errorLogs.length}`);
        console.log(`‚ö†Ô∏è Avisos: ${warningLogs.length}`);
        console.log(`‚ÑπÔ∏è Info/Log: ${infoLogs.length}`);
        
        if (errorLogs.length > 0) {
            console.log('\nüö® ERROS CR√çTICOS ENCONTRADOS:');
            errorLogs.slice(0, 5).forEach((error, index) => {
                console.log(`  ${index + 1}. ${error.text}`);
            });
        }
        
        if (infoLogs.length > 0) {
            console.log('\n‚úÖ LOGS INFORMATIVOS (Primeiros 5):');
            infoLogs.slice(0, 5).forEach((info, index) => {
                console.log(`  ${index + 1}. ${info.text}`);
            });
        }
        
        console.log('\nüîç AN√ÅLISE 4: ELEMENTOS DOM E ESTRUTURA');
        const title = await page.title();
        console.log(`üìÑ T√≠tulo da p√°gina: "${title}"`);
        
        // Verificar estrutura DOM espec√≠fica
        const domStructure = {
            hasReactRoot: await page.locator('#root').count() > 0,
            hasAppContent: await page.locator('[class*="App"], [id*="App"]').count() > 0,
            hasNavigationContainer: await page.locator('[class*="navigation"]').count() > 0,
            hasLoginScreen: await page.locator('[class*="login"], [data-testid*="login"]').count() > 0,
            hasErrorBoundary: await page.locator('[class*="error"]').count() > 0
        };
        
        console.log('üèóÔ∏è Estrutura DOM:', domStructure);
        
        console.log('\nüîç AN√ÅLISE 5: CAPTURA DE TELA');
        const screenshotPath = './treinosapp-status-analysis.png';
        await page.screenshot({ 
            path: screenshotPath, 
            fullPage: true 
        });
        console.log(`üì∏ Screenshot salvo: ${screenshotPath}`);
        
        console.log('\nüîç AN√ÅLISE 6: TIMING E PERFORMANCE');
        console.log(`‚è±Ô∏è Tempo de carregamento inicial: ${loadTime}ms`);
        
        const loadingElements = await page.locator('[class*="loading"], [class*="spinner"]').count();
        if (loadingElements > 0) {
            console.log(`üîÑ Elementos de loading detectados: ${loadingElements}`);
        }
        
        console.log('\nüîç AN√ÅLISE 7: REQUISI√á√ïES DE REDE');
        console.log(`üì° Total de requisi√ß√µes: ${networkRequests.length}`);
        if (networkRequests.length > 0) {
            console.log('üì° Principais requisi√ß√µes:');
            networkRequests.slice(0, 10).forEach((req, index) => {
                console.log(`  ${index + 1}. ${req.method} ${req.url}`);
            });
        }
        
        // RESUMO FINAL
        console.log('\n' + '='.repeat(60));
        console.log('üìã RESUMO DA AN√ÅLISE - STATUS DAS CORRE√á√ïES');
        console.log('='.repeat(60));
        
        const analysisResult = {
            registerWebModuleError: !registerError,
            renderingWorking: hasSignificantContent,
            criticalErrors: errorLogs.length,
            hasContent: domStructure.hasReactRoot,
            loadTime: loadTime,
            totalLogs: consoleLogs.length
        };
        
        // Status do erro registerWebModule
        if (analysisResult.registerWebModuleError) {
            console.log('‚úÖ Erro registerWebModule: CORRIGIDO');
        } else {
            console.log('‚ùå Erro registerWebModule: AINDA PRESENTE');
        }
        
        // Status da renderiza√ß√£o
        if (analysisResult.renderingWorking) {
            console.log('‚úÖ Renderiza√ß√£o: FUNCIONANDO (n√£o mais tela branca)');
        } else {
            console.log('‚ùå Renderiza√ß√£o: AINDA COM PROBLEMAS');
        }
        
        // Status dos logs
        if (analysisResult.criticalErrors === 0) {
            console.log('‚úÖ Logs: LIMPOS (sem erros cr√≠ticos)');
        } else {
            console.log(`‚ö†Ô∏è Logs: ${analysisResult.criticalErrors} erros cr√≠ticos encontrados`);
        }
        
        // Status geral
        const isFixed = analysisResult.registerWebModuleError && 
                       analysisResult.renderingWorking && 
                       analysisResult.criticalErrors === 0;
        
        if (isFixed) {
            console.log('üéâ STATUS GERAL: CORRE√á√ïES FORAM TOTALMENTE EFETIVAS!');
        } else if (analysisResult.registerWebModuleError && analysisResult.renderingWorking) {
            console.log('‚úÖ STATUS GERAL: CORRE√á√ïES PRINCIPAIS EFETIVAS - Alguns erros menores detectados');
        } else {
            console.log('‚ö†Ô∏è STATUS GERAL: AINDA H√Å PROBLEMAS SIGNIFICATIVOS');
        }
        
        // Salvar relat√≥rio detalhado
        const report = {
            timestamp: new Date().toISOString(),
            loadTime: loadTime,
            analysisResult: analysisResult,
            domStructure: domStructure,
            consoleLogs: consoleLogs,
            errors: errors,
            networkRequests: networkRequests.slice(0, 20) // Apenas as primeiras 20
        };
        
        fs.writeFileSync('./treinosapp-analysis-report.json', 
                        JSON.stringify(report, null, 2));
        console.log('üìä Relat√≥rio detalhado salvo: treinosapp-analysis-report.json');
        
        return analysisResult;
        
    } catch (error) {
        console.error('‚ùå Erro durante an√°lise:', error.message);
        throw error;
    } finally {
        await browser.close();
    }
}

// Executar a an√°lise
analyzetreinosappStatus()
    .then(result => {
        console.log('\nüèÅ An√°lise conclu√≠da com sucesso!');
        console.log('üìä Resultado:', result);
    })
    .catch(error => {
        console.error('\nüí• Falha na an√°lise:', error.message);
    });